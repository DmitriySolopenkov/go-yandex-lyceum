# Функции в Go

> **Функции**
>
> Основные строительные блоки программ в Go. Они позволяют создавать модульный и масштабируемый код. В этом уроке мы рассмотрим, как создавать и использовать функции в Go.

Изученного материала уже хватает для написания небольших программ. Мы можем построчно писать код, но его пока тяжело переиспользовать. При этом программы достаточно часто требуют переиспользование одного и того же участка кода много раз.

Для этого и существуют так называемые «Функции». Вообще, мы с вами уже написали большое количество функций, но не говорили об этом, чтобы не пугать. :)

> func main() — тоже функция, причём главная функция в программе.

Давайте углубимся в эту тему и прокачаем наши программистские навыки. Для начала напишем программу, которая вычисляет дискриминант от квадратного уравнения:

```golang
func main() {
    a := 1.0
    b := -3.0
    c := 2.0

    discriminant := math.Pow(b, 2) - 4.0*a*c // math.Pow возводит b в степень 2
    fmt.Println(discriminant)                // Вывод: 1
}
```

Кажется, что все хорошо, но если мы захотим в одной программе считать несколько таких уравнений, то нам придётся много раз копировать и вставлять строчку с вычислением дискриминанта.

```golang
func main() {
    a := 1.0
    b := -3.0
    c := 2.0

    discriminant := math.Pow(b, 2) - 4.0*a*c
    fmt.Println(discriminant)

    a = 2.0
    b = 4.0
    c = 2.0

    discriminant = math.Pow(b, 2) - 4.0*a*c
    fmt.Println(discriminant) // Вывод: 0 
}
```

И чем больше мы будем писать кода, тем объемнее и сложнее для понимания будет выглядеть наша программа. Для таких случаев мы, как и в математике, можем воспользоваться функциями.

## Сигнатура функции

> **Сигнатура функции**
>
> Термин, обозначающий название функции и её параметры.

В случае с функцией, вычисляющей факториал, её сигнатура выглядит так:

```golang
func factorial(n int) int
```

Здесь "factorial" — название функции, "n int" — параметр функции, который должен быть целым числом, а "int" — тип возвращаемого значения.

```golang
func findDiscriminant(a, b, c float64) {
    
}
```

Функция объявляется с помощью ключевого слова func. Далее мы передаём название функции, а в круглых скобках можем передать аргументы (переменные с их типом). Далее в фигурных скобках следует так называемое тело функции — это то место, где мы пишем то, что должен делать код.

Также можно использовать аргументы разного типа. Для этого нужно указать после каждого параметра его тип:

```golang
func createUser(name string, age int, weight float64) {}
```

Здесь мы объявили три параметра разных типов. Если у нас присутствует несколько однотипных параметров, идущих друг за другом, то не обязательно после каждого из них указывать тип данных:

```golang
func createUser(name, phoneNumber, secondName string, age int, weight float64) {}
```

Давайте немного изменим нашу программу:

```golang
//   название         аргументы с типом
func findDiscriminant(a, b, c float64) {
// тело функции
    discriminant := math.Pow(b, 2) - 4.0 * a * c
    fmt.Println(discriminant)
}

func main() {
    findDiscriminant(1, -3.0, 2) // a = 1  b = -3.0  c = 2  
    findDiscriminant(1, 4.0, 2). // a = 1  b = 4.0   c = 2  
}

// Вывод: 1
// Вывод: 0
```

Мы выделили вычисление и вывод дискриминанта в отдельный переиспользуемый блок кода. Далее, чтобы вызвать функцию, пишем её название и в скобках передаём данные, с которыми функция должна вызываться, и в том порядке, в котором мы объявляли аргументы.

На этом этапе функция может делать какую-либо последовательность операций и выводить данные в консоль с помощью fmt.Println.

### Возвращаемые функцией значения

Если дальше нам нужен сам результат, а не вывод его в консоль, то мы используем Возврат значений. Это делается с помощью ключевого слова return. В сигнатуре функции мы обозначаем, какого типа значения функция должна вернуть.

```golang
//                        тип возвращаемого значения
//                                        |
func findDiscriminant(a, b, c float64) float64 {
    
}
```

Перепишем ещё раз нашу программу:

```golang
func findDiscriminant(a, b, c float64) float64 {
    discriminant := math.Pow(b, 2) - 4.0 * a * c

    // возвращаем значения вычисления из findDiscriminant
    return discriminant
}

func main() {
// в данном случае Println внутри себя вызовет функцию и выведет на консоль результат её выполнения
    fmt.Println(findDiscriminant(1, -3.0, 2))
    fmt.Println(findDiscriminant(1, 4.0, 2))
}
```

Таким образом, мы с вами научились выделять из нашего кода переиспользуемые части и возвращать из них какие-либо значения.

Предлагаем выполнить задания для закрепления новых знаний:

* Написать три функции и выводить их результаты в консоль. Функции: складывание двух чисел, вычитание двух чисел, умножение двух чисел. Результат выполнения должен быть в виде одного числа.
* Написать консольный калькулятор, который выведет результаты в виде:

```bash
Добро пожаловать в калькулятор!
Введите первое число: 10 // пользовательский ввод
Введите второе число: 5  // пользовательский ввод
Результат сложения: 15
Результат вычитания: 5
Результат умножения: 50
```

Для пользовательского ввода воспользуйтесь функцией fmt.Scanf из стандартного пакета fmt.

## Вызов функции

### Множественные параметры и множественный возврат

Язык Go даёт возможность выводить сразу несколько значений из функции. Это помогает нам, когда какая-то функция должна возвращать 2, 3 и более значения.

Например, вы захотели добавить в свой калькулятор функцию деления и нужно вывести отдельно целую часть и остаток. Язык программирования даёт нам такую возможность.

Чтобы её использовать, нужно указать типы значений, которые хотим получить.

```go
func divide(a, b int) (int, int) {}
```

В данном случае оба возвращаемых значения будут целочисленного типа.

Напишем тело функции:

```go
func divide(a, b int) (int, int) {
    integer := a / b
    remainder := a % b
    return integer, remainder
}
```

Как мы видим, достаточно передать обе переменные в том порядке, в котором хотим их вывести.

Вот ещё один пример функции с несколькими параметрами и несколькими возвращаемыми значениями в Go:

```go
func calculateAreaAndPerimeter(length, width float64) (float64, float64) {
    area := length * width
    perimeter := 2 * (length + width)
    return area, perimeter
}
```

Эта функция принимает два параметра length и width, оба типа float64. Затем она вычисляет площадь и периметр прямоугольника, используя эти значения, и возвращает оба значения в переменные типа float64.

Чтобы вызвать функцию calculateAreaAndPerimeter и получить оба возвращаемых значения, мы можем использовать следующий код:

```go
area, perimeter := calculateAreaAndPerimeter(10.0, 5.0)
fmt.Println("Площадь:", area)
fmt.Println("Периметр:", perimeter)
```

Это выведет:

```bash
Площадь: 50
Периметр: 30
```

Здесь присвоили два возвращаемых значения переменным area и perimeter. Затем мы можем использовать эти переменные по мере необходимости.

Использование функций с несколькими параметрами и возвращаемыми значениями может сделать наш код более модульным, лёгким для чтения и поддержки.

> В данном уроке мы рассмотрели основы функций в Golang. Мы изучили, как объявлять функции, передавать аргументы, возвращать значения и использовать множественные параметры и возвращаемые значения. Функции — мощный инструмент в языке Go, который позволяет разбивать код на переиспользуемые блоки и упрощать его структуру.

## Рекурсия

**_Мы уже изучили тему функций, и теперь пришло время перейти к более сложной теме._**
> **Рекурсивная функция**
> Функция, которая вызывает сама себя.

Однако, как и любая другая функция, она должна иметь результат выполнения, и для этого нам нужен способ выйти из неё.

Начнём с расчёта факториала. Чтобы понять, как решить его рекурсивно, напишем алгоритм расчёта факториала.

* Если n равно 0, то факториал n равен 1.
* Иначе — факториал n вычисляется как произведение всех целых чисел от 1 до n.

```bash
0! = 1
1! = 1
2! = 2 * 1 = 2
3! = 3 * 2 * 1 = 6
4! = 4 * 3 * 2 * 1 = 24
5! = 5 * 4 * 3 * 2 * 1 = 120
```

Как мы можем заметить, каждая итерация расчёта происходит со значения n-1, то есть используя предыдущее вычисленное значение. В данном случае мы можем перевести это в рекуррентный алгоритм — такой, который содержит обращение к самому себе.

```go
func factorial(n int) int {
    // крайний случай
    if n == 0 {
        return 1
    }
    // вызов функции с текущим значением умноженным на результат (n-1)
    return n * factorial(n-1)
}

func main() {
    result := factorial(5)
    fmt.Println(result)
}
```

Как это работает под капотом. Вызвав рекуррентную функцию, мы составим последовательность вызовов, каждый из которых будет расчитывать значение только для себя и передавать расчёт остальным функциям, вызывая их со значением (n-1), как бы уходя вглубь. Это называется глубина рекурсии. В нашем случае глубина рекурсии равна 5.

Посмотрите, результаты верхних функций зависят от того, что вернула каждая следующая функция.

Рассмотрим ещё один случай — последовательность Фибоначчи.

Данная задача: нужно посчитать количество чисел после каждой итерации, но с условием, что на каждой итерации воспроизводится f(n-2) + (f-1) элементов. Давайте рассчитаем письменно то, как это будет выглядеть:

```bash
f(0) = 0
f(1) = 1
f(2) = f(1) + f(0) = 1 + 0 = 1
f(3) = f(2) + f(1) = 1 + 1 = 2
f(4) = f(3) + f(2) = 2 + 1 = 3
f(5) = f(4) + f(3) = 3 + 2 = 5
```

На каждом шаге мы рассчитали вызовы функций с определёнными значениями, чтобы лучше понимать сам алгоритм. Давайте теперь реализуем его в коде.

```go
func fib(n int) int {
    // крайний случай, так как при f(1) и так далее мы не сможем посчитать обе      следующих итерации
    if n < 2 {
       return n
    }

    return fib(n-1) + fib(n-2)
}

func main() {
    fmt.Println(fib(6)) // Вывод: 8
}
```

В данном случае наша программа создаёт уже две функции на каждый вызов, но принцип работы тот же. Предлагаю попробовать самим простроить цепочку вызовов данной задачи и сравнить с результатом. Пока что посмотрим на дерево вызовов.

Здесь мы можем наглядно видеть вызов каждой функции с каждым аргументом передаваемым в неё.

При использовании рекурсии можно сохранять промежуточные результаты, чтобы ускорить программу. Это называется мемоизацией и является распространённой техникой оптимизации рекурсивных алгоритмов. Да, очень много непонятных слов, но не стоит расстраиваться, уже в следующем уроке мы разберёмся в их значении и том, как мы всё-таки можем оптимизировать наши рекурсивные программы.

> **Рекурсия**
>
> Сильный инструмент, который можно использовать для решения многих задач.
>
> Как правило, рекурсия используется в следующих случаях:
>
> * Для решения задач, которые могут быть определены рекурсивно, к примеру, вычисление факториала или чисел Фибоначчи.
> * Для решения задач, которые связаны с деревьями или другими структурами данных, которые могут быть определены рекурсивно.
>
> С другой стороны, рекурсию не следует использовать в следующих случаях:
>
> * Для решения задач, которые могут быть решены итерационным способом.
> * Для решения задач, которые могут привести к переполнению стека или другим проблемам производительности. Переполнение стека — ошибка, при которой программа захватывает всю память, выделенную ей под стек (специальная области памяти), что обычно приводит к аварийному завершению её работы

Рекурсия — пусть и мощный инструмент, но использовать его нужно с осторожностью и только тогда, когда это действительно необходимо.

В этом уроке мы поняли, что такое рекурсия и как её использовать. Это хороший приём для решения сложных задач связанных со структурами данных, о которых вы узнаете чуть больше в следующих уроках.
